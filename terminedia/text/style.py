"""Tokenizer and tree-structure for style-applying in text.

Allows one to encode in a single string style changes
instead of having to chunk pieces of text
to change the context for color, effects and transform changes


Also, [future] enable the parsing of more than one
markup style - for example, allowing terminedia
to extract color and movement information from
ANSI text streams generated by other apps.


TMMarkup example:


here comes some text [color:blue] with apples [background:red] infinite [/color /background effect:blink]in joy and blink[/effect]
[direction:up]happy[effect:bold]new year[/effect][direction:left]there we go[/direction]up again[direction: right] the end.


"""
from __future__ import annotations

import typing as T

from terminedia.contexts import Context
from terminedia.utils import V2

class StyledSequence:


    def __init__(self, text, mark_sequence, text_plane=None, context=None, starting_point=None):
        """
        Args:
          text (Sequence): the stream of characters to be rendered  - it can be a string or a list of 1-grapheme strings.
          mark_sequence (Mapping): A mappign with Mark objects. The keys either represent index positions on the text
            where the mark will be processed, or they can be at the special index "config" denoting marks
            that are to have their indexes processed according to other enviroment circunstances
            (like the current "tick" - and possibly 'current position')
            The value at each item can contain a single Mark or a of Markers.
          text_plane (terminedia.text.planes.Text): area where the output is to be rendered
            on iterating. The Text object will be searched for aditional "Mark" objects that
            will compose the syle and position when encountered (they are less
            prioritary than the Marks passed in mark_sequence)
            If no Text object is given, the instance may still be iterated to retrieve
            a sequence of char, context and position - for example, when generating
            output directly to a tty.
          context (terminedia.Context): parent context. By default the context
          attached to the given text_plane is used
          starting_point: first position to be yielded when iteration starts (from which
            rules apply according to context.direction and others given by the matched
            "Mark" objects. Defaults to (0, 0)



        Helper class to render text that will both hold embedded style information,
        conveyed in "Mark" objects (with information like "at position 10, push foreground color 'red'"),
        and respect Mark objects embedded in the "text_plane" associanted rendering space.

        Style changes are all on top of a given "parent context"
        if any (otherwise, the text_plane context is used, or None)

        The rendering part include yielding the proper position of each
        rendering character,as contexts convey also
        text printing direction and marks can not only
        push a new printing direction, but also "teleport" the
        rendering point for the next character altogether.


        """
        self.text = text
        self.mark_sequence = mark_sequence
        self.parent_context = context
        self._last_index_processed = None
        self.context = Context()
        self.text_plane = text_plane
        self.starting_point = V2(starting_point) if starting_point else V2(0,0)
        self.current_position = self.starting_point
        self._context_layers = 0
        self._sanity_counter = 0

    def _process_to(self, index):

        if self._last_index_processed is None and index == 0:
            self.current_position = self.starting_point
        elif self._last_index_processed is None or index != self._last_index_processed + 1:
            self._sanity_counter += 1
            if self._sanity_counter > 1:
                raise RuntimeError("Something resetting marked text internal state in infinite loop")
            self.context._clear()
            self._context_layers = 0
            self._last_index_processed = None
            for i in range(0, index + 1):
                self._process_to(i)

            self._sanity_counter -= 1
            return self.context

        mark_here = self.mark_sequence.get(index, EmptyMark)
        if mark_here is not EmptyMark:
            mark_here.context = self.context
            mark_here.pos = self.current_position
        if mark_here.attributes:
            self._context_push(**mark_here.attributes)
        if mark_here.moveto:
            self.current_position = V2(mark_here.moveto)
        if mark_here.rmoveto:
            self.current_position += V2(mark_here.rmoveto)
        self._last_index_processed = index
        return self.context

    def _context_push(self, **kwargs):
        # FIXME - have a 'lightweight layers' Context class instead of doing this.
        # (or maybe, keep doing the __enter__ call, but having a lighter 'enter'
        #  than the current implementation (2020-06-16), which creates a new
        # Context instance)
        self.context(**kwargs).__enter__()
        self._context_layers += 1

    def _context_pop(self, n=1):
        for i in range(n):
            self.context.__exit__(None, None, None)
            self._context_layers -= 1

    def _unwind(self):
        self._context_pop(self._context_layers)

    def _get_position_at(self, char, index):
        if self._last_index_processed != index:
            self._process_to(index)
        position = self.current_position
        self.current_position += self.context.direction
        # TODO: handle double-width characters
        return position

    def __iter__(self):
        for index, char in enumerate(self.text):
            yield self.text[index], self._process_to(index), self._get_position_at(char, index)
        self._unwind()

    def render(self):
        if not self.text_plane:
            return
        # FIXME: if self.parent_context is not self.text_plane.owner.context, combine parent and current context
        # otherwise combination is already in place at the render_lock
        render_lock = self.text_plane._render_styled(self.context)
        try:
            char_fn = next(render_lock)

            for char, context, position in self:
                char_fn(char, position)
        finally:
            try:
                next(render_lock)
            except StopIteration:
                pass

class Mark:
    """Control object to be added to a text_plane or StyledStream

    The object indicate which context attributes or text position
    enter in effect at that point in the stream.

    Instances of this are to be automatically created on parsing markup strings or
    or other input - but can be hand-crafted for special effects.


    """
    # This is supposed to evolve to be programable
    # and depend on injected parameters like position, ticks -
    # like transformers.Transformer

    # For the time being, subclass and use 'property'.
    # 'context' and 'pos' attributes are set on the instance
    # prior to reading the other property values.

    __slots__ = "attributes moveto rmoveto context pos".split()
    attributes: T.Mapping
    moveto: V2
    rmoveto: V2
    def __init__(self, attributes=None, moveto=None, rmoveto=None):
        self.attributes = attributes
        self.moveto = moveto
        self.rmoveto = rmoveto

    def __repr__(self):
        return f"Mark({('attributes=%r, ' % self.attributes) if self.attributes else ''}{('moveto=%r, ' % self.moveto) if self.moveto else ''}{('rmoveto=%r' % self.rmoveto) if self.rmoveto else ''})"


EmptyMark = Mark()


#class StyledStream:
    #def __init__(self, tokenstream):
        #self.data = tokenstream

    #def __iter__(self):
        #for item in self.data:
            #yield item

    #def __len__(self):
        #return len(self.data)




def split_graphemes(text):
    """Separates a string in a list of strings, each containing a single grapheme:
    the contiguous set of a character and combining characters to be applied to it.
    """

    category = unicodedata.category

    result = []
    for char in text:
        if not category(char)[0] == 'M' or not result:
            result.append(char)
        else:
            result[-1] += char
    return result



class Tokenizer:
    pass

class MLTokenizer(Tokenizer):
    pass

class ANSITokenizer(Tokenizer):
    pass
