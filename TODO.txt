Targeted for next release (0.3):
=================================
Partial windows support (cmder and maybe microsoft's new terminal):
    - install and activate colorama if under windows
    - create a non-blocking keybard reading system using mscrvt api

Resolve "can't output a lot of things to terminal if stdin set to non blocking" bug on windows

smaller features:
    - improve interactive usage of Screen on the repl: option to move the cursor to the bottom and prevent attribute caching when under interactive use.
    - use the same option of suppressing absolute cursor movement for the html backend.
    - uniformize "size", "get", "set" and __getitem__ & __setitem__ on screen, shape, high and braille namespaces.
    - accept context attributes (color, background, effects) as keyword arguments on all .draw methods
    - fix palleted shapes:
        - create proper booleanshape (true/false + color) - used by default to render fonts.
        - reading with __getitem__ should get back a pixel with the original character, but when blitting, only the color and boolean information should be blitted (color.TRANSPARENT should imply in "False" pixels)
        - on drawing, context.char should be respected - and auto-appended to the color_map if not there.
    - make emoji's and unicode chars easier to use:
        - expose unicodedata databases as plain dictionaries
        - implement basic search for character names with partial match
            (eg: so that one can search for all characters containing "square" or "chess" in the name)
    - enable "debug" flag in root context and display internal information on object's repr based on that
            (currently Screen's repr is showing last_pos, last_color, and other internal state attrs by default)
    - shape "clear" call:
        - optional parameter to reset text information
        - method to redraw text from a given plane/roi.
    - bug: Screen.clear() should clear the associated shape in Screen.data

    - bug: html rendering not respecting context colors, on starting empty space characters
    - bug: with terminal in relative movement, snake-game is faulty,, suggesting terminal-context bugs
    - bug: (may be postponed) - shape.render does not respect shapesviews (slices): the parent shape is rendered instead


Transformers [WIP]:
    Transformers are a generic word for filters, which include attached shapes that will work as extra layers.
    Improve context transformers to become a friendly, stackable class with defined API:
        - a Transformer container class is attached to each context in "transformers"
        - if enabled, shape data will be kept in a "shadow" buffer with the original content, all write operations are to the "shadow" and all read operations from the parent shape read the transformed content.
        - (The 'Shadow" buffer is a Shape object - an extra flag should be added to shapes so that only the base Shape have "transformers" applied to it. Otherwise, the shadow buffer uses the same context as the parent)
        - This design should allow a filter to read random pixels from the shadow buffer, and not the pixel being written - this will enable the creation of convolution filters
        - TranformersContainer:
            - a specialized sequence to hold a Transformers stack for each context
            - exposes "char", "foreground", "background" and "effect" properties which
            - yield the final value for a pixel in a given position when it is read via "__getitem__" in a Shape
        - Transformer:
            a class with slots for each possible transformation a pixel might go through:
                - char, foreground, background, effect, filter, spatial and source
                    - spatial is a specialized object containing a 3x3 transformation matrix - which is applied in reverse
                    order to fetch the pixel (nearest neighbour) on the source data-shape.

                    - filter: (maybe not needed - the idea would be to look at neighbourhood pixels at the source
                               and apply an effect depending on the neighbours. But possibly this should go straight
                               in the "char ... effects" slots.)
                    - source: if given, a shape that is blitted over the target
                        shape (otherwise the source is a "shadow" shape). Pixels from a given source
                        are combined with pixels from the shadow, according to
                        some combination semantics. Default is "normal" which just replaces
                        pixels comming from the shadow-shape in the transform pipeline with the values
                        from the source-shape. This allows
                        Transformer + Shape + Spatial work as a "sprite" mechanism.
                        - *future* : combination and layer modes other than "normal".

                - Spatial - class embedding a 2D (3X3) transformation matrix with friendly properties
                to specify linear transformations in a friendly way.

    create some filters as ready-made transformers (maybe not all for 0.3.0):
        - threshold: yield true/false pixels and strip color information
        - convert colorred fullblock pixels to "transparent" pixels: keep the existing char, and apply the color as background
        - color-value to different unicode-circles
        - color-value to different unicode-squares
        - linear gradients

breaking-changes:
    - rename unicode effects so that their name matchs their unicode names (at least "super_bold" -> "regional_indicator")

3.1:
========
Write some real nice docs, with tutorials and use suggestions


Future
========
    Image 'screenshot' backend
    image backend (pixels are simple color-only boring, image pixels)
    postscript backend
    .rtf backend
    pdf backend
    Fallback terminal to 1-byte color setting for up to 216 colors + 24 grayscale

- new "resolution modes":
    - half character (1/2 block - square aspect ratio)
    - double-character (2 blocks - square aspect ratio)
        - Add a Text[2] plane using braille chars(WIP)
        - create a solution equivalent to the ".text[4]" plane selection for resolutions
    - sextant (1/6 block) (depends on unicode 12 with vintage charset), with square aspect ratio:
    - 1 block width x 1 block height at arbitrary 1/8 block height position. (use "LOWER ONE EIGHTH BLOCK" and friends)
    - 1 block width x 1 block height at arbitrary 1/8 block width position.
    - refactor image loading to be able to use super-resolutions for B&W, while keeping color resolution low (Speccy way)
     - Update "text-effects" example to fit more effects to come.

Find a way to find witch unicode-glyphs are available in system-wide fonts
    - suggest font-installation
    - (or) download free-fonts to terminedia data folder (but how to make the host terminal use them?)
    - refactor unicode-translations to include correct information about the characters used, with links back to proper unicode documentation (including the motivation for theis inclusion)

Convolution-dependant effects:
    - smooth-out corners
    - use unicode circles and squares to denote intensity
    - conversion to ASCII line-art with "/_\|" chars, and unicode version
    - conversion to table chars (single and double-frame)
    - Couple with "find border" filter(?)

"page" abstraction expanding the "shape": including text regions, layers and animation effects

easy way to pick unicode emojis and glyphs

alpha channel support for images:
    plot with spaces (" ") instead of full-block char, and compose color using background

support to z-index, and background keeping on blitting ("sprite" api)

MS-Windows support (colorama/mscrvt/color reducing)

"business" framed-window api

Basic image transform API: resize, rotate, flip.

Table drawing chars drawing API (maybe convert chars with a convolution after block-line art?)

Super-high resolution (Unicode vintage charset and "sextant" blocks)

Mouse event support

Audio support (pyAudio?)

Image (shape) transform - (rotate, scale).

paint modes to use different characters to denote intensity (back do ascii art):
    unicode circles
    unicode squares
    Classic ASCII # * . etc
    Block-smoothing with half triangle block chars
    (use a context "paint mode" to have this supported on all paint operations?)
    (use a special "effects" attribute and apply a convolution variant with a transformer?)

"gradients": ways to make easy to create gradually changing colors.
             possibly a "painting context" similar to Cairo's, instead
             of a plain value for foreground color. Then color
             for each pixel could be sourced from a shape, image,
             gradient, whatever.
             But whatever is done, have ways for it being simpler to
             use than cairo's contexts.'
             (Hint: already possible on "user side" by using context-transformers)

replicate text-char effects for big-chars

Graph plotting CLI
    make terminedia available as a matplotlib backend

alpha emulation using background and color manipulation

gaming framework in general:
    (integrate as a backend to "jsbueno/mapengine"?)
    sprites
    physics engine (minimal, 2D)
    animation support
    main loop

"main loop":
    - event system
    - loop dependant 'blink like" animations: cicle colors, characters, text based on timing


space invaders implementation (hint: it would be already feasible - but it is still a "landmark" of the roadmap)


# virtual terminal server-
Advanced terminal handling features
    REPL Environment wit bottom lines for python console and upper screen for image (see posix_openpt)
    anmating and coloring text output of unaware apps, by creating an internal virtual terminal (posix_openpt)
    animating and coloring text output ... monkey patching a subprocess stdin, stdout and stderr.
    handle scrolling capabilities and pre-post buffer
    terminal agnostic screen commands (terminfo and infocmp to de-hardcode ANSI sequences)
    implement SIGWINCH signal handler to enable auto-resize/reflowing on terminal window size change
        check if there is a ms-windows equivalent

more features
###############
    Add text formatting and flowing primitives into ".text" namespace:
        method to allow text insertion and flowing inside a shape or ROI
        allow center/left/right/justify alignments
    Add scrolling, rectangular text regions and flowing text
    All-side scrolling and flowing text from one region to the next
    (make text.at work with the @ operator?: `sc.text[4] @ (5,2)("hello!")(?)
    read font "planes" on demand (WIP - only the first 256 chars are loaded)
    Find proper API do render 8x16 pixel fonts into 8x8 char "high-resolution" 1/4 block.
    Add arbitrary font handling by using PIL to cache rendered chars.
    Enable 16 x 8 double and 16 x 16 double width UNSCII fonts.
    create a "blit fast path" for value/palette shapes to target (avoid overhead of pixel creation)
    make "Alpha" value work for value-shapes.
    make "intensity" rendering for values (B&W shapes)
    (them proceed to write the different backends.)
        - Accept 0-255 or 0-1.0 3 [4] sequences for RGB color [Alpha]
        - conversion to 1-byte standard 216 color palette for terminals
        - make use of 1byte color on terminal.py
    Assume `set` method passed to drawing.Drawing can always accept pixels. Simplify workarounds in "image.ShapeApiMixin" and "screen.set_at" to accept pixels. (API breaking - change this before making a release)


Enhance EMOJI and multi-language support:
    - handle combining characters properly
    - document which terminal applications will have the best emoji experience (check kitty terminal app)

shape and page capabilities:
    create full fledged shape with char, fg, bg, effects (WIP - only missing example script):
        Add example script using FullShape and transformers(terminedia-text)
    create "Page" class: contaning several z-ordered shape or ROIs for text layout

- implement fix at drawing.blit (N/A - blit simply copies CONTINUATION constant normally)
- implement fix at terminal.Commands.print (N/A - 'CONTINUATION' constant never reaches terminal functions)
- [future]:
    - check double width chars at UNSCII 16 for proper use at other text scales
    - if needed implement the logic above at text[4], [8], etc...

Features and improvements
=========================
    fix-paletted-shape-blitting-bug
    fix-value-shape-blitting-bug
    refactor bezier-curve and ellipse(empty) adaptive code to use same codebase
    configure properly and make consistent use of logger
    Improve error messages/or silence/ when attempting to write out of Screen/Shape limits
    generate documentation
    Add missing doc-strings
    improvement: API for  X-session wide key-repeat tunning with "xset r rate".
            (Maybe, in combination with other features, it is even possible to have keydown/keyup emulation)
            What is the equivalent API for Win and Mac if any?
    Make internal FullShape planes (and maybe other Shapes) specialized containers (they are plain lists): enable direct attribute setting on plane (rename  attributes in the process) (maybe trim further down shape class, and make internal planes for shapes, shapes as well?)
    create a few ready-made, parametrized transformers for effects like: plane select, color gradients, mask blit,
    Update "Context" to use context-locals (async aware) instead of thread-locals
    Add a "clear" draw method to empty-up a target.
    Drawing APIs not respecting ShapeView limits (V)
    add "callback" or early event system so that context parameters can be changed after printing a character, or other event.
    set up internal state on which terminal program is running, basd on env-vars (so that terminal behaviors bugs can be work-around)
    work on special methods to allow pickle serialization of shapes and maybe screens.

Color class Todo:
    Future:
    - Add support for gray colors (single int)
    - Add support for alpha-component
    - Add support for HSL parsing/conversion

HTML-Backend Steps (WIP)
    future
    ------
    Hardwire a web-font to display braille characters as pixels (UNSCII?)
    Refactor rendering mechanism to speed things up (0.2 sec/frame = 10 times too slow)
    Render with a separate CSS block and classes instead of inlining style in all tags.
    WSGI compatible server and javascript snippet to enable frame rendering and update
    keyboard and mouse event handling on server.
    create HTML Canvas output (?)
    create SVG output (?)
    Add text effects to take advantage of transforms available in HTML/SVG (rotate, rescale, transparency)
    Ability to emulate Unix terminal on HTML comonent (posix_openpt)
    Full-client-side implementation (using brython or similar)


Bugs
=====

    bug: plot example script prints completly bogus values on the y scale.
    bug:fix printing of colored double-width characters . (b0rk on konsole) (WIP)
    bug: when apple shows up over snake body, it is erased from screen (snake.py) (easy) (external) (hacktober)
    bug: Screen.clear() should clear the associated shape in Screen.data.
    bug: Effects.super_script not working for letters 'n' and 'q' - check if there is a suitable custom glyph
    bug: Pallette shapes need to be overhauled - currently tests are broken due to reading from it back just yielding "True" and "False"
    bug: (big issue): workaround stdout blocking and raising error when in input.keyboard reading mode.
